<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>beforeRunningCommand</key>
	<string>nop</string>
	<key>command</key>
	<string>#!/usr/bin/env ruby
require "#{ENV['TM_BUNDLE_SUPPORT']}/lib/linkage.rb"

# working on incorporating existing refs:
# when pasting, avoid duplicates in both urls and ref names
# when listing links, include existing refs in addition to clipboard
# when linking text, check url against refs, use ref format if exists
#
# input = ENV['TM_SELECTED_TEXT'] ? ENV['TM_SELECTED_TEXT'] : ENV['TM_CURRENT_WORD']
# document = STDIN.read
# refs = document.scan(/\[([^\]]+)\]\:\s/)
# refs.sort!

linker = Linkage.new

if ENV['TM_SELECTED_TEXT'].nil?
	left_edge = ENV['TM_LINE_INDEX'].to_i-2 &lt; 1 ? 0 : ENV['TM_LINE_INDEX'].to_i-2
	left_char = ENV['TM_CURRENT_LINE'].slice(left_edge..ENV['TM_LINE_INDEX'].to_i)
	if left_char =~ /\s?\b([stbwn])\b/
		case $1
		when "w" then
			title,url = linker.web_search("")
		when "t" then
			title,url = linker.make_tag_link("")
		when "b" then
			title,url = linker.make_blog_link("")
		when "s" then
			title,url = linker.make_search_link("")
		# when "n" then puts "news search"
		end
		TextMate.exit_discard if title == false
		if !(ENV['TM_SCOPE'].scan(/markdown/).empty?) &amp;&amp; ENV['TM_CURRENT_LINE'] =~ /^[stbwn]\b(\s+)?$/
			linker.replace_if_needed("[#{title}]: #{url}")
		else
			linker.replace_if_needed("[#{title}](#{url})")
		end
		exit
	end
end

# Let's get on with it
TextMate.exit_discard if ENV['TM_CURRENT_LINE'] =~ /^(doctype|title|categories|tags): /i
linker.find_main_link if ENV['TM_CURRENT_LINE'] =~ /^[Ll]ink: /i
fullmatch,linkword,word_is = linker.is_linked(INPUT) unless INPUT.nil?

if linkword
  if word_is == "title"
    TextMate::CoolDialog.cool_tool_tip("Run the linker in the link portion of the reference - #{linkword}",true)
  elsif word_is == "link"
    references = linker.references.clone.delete_if {|x| x['title'] == linkword }
    linklist = references.collect { |e| { 'title' =&gt; e['title'].to_s } }
    plist = { 'menuItems' =&gt; linklist }.to_plist
    res = OSX::PropertyList.load(`#{e_sh DIALOG} -up #{e_sh plist}`)
    TextMate.exit_discard unless res.has_key? 'selectedMenuItem'
    newlink = fullmatch.slice(0..fullmatch.index('][')) + "[#{res['selectedMenuItem']['title']}]"
    linker.replace_whole_ref(fullmatch,newlink)
    exit
  else
    TextMate::CoolDialog.cool_tool_tip("Not linked",true)
  end
end

if linker.links.empty? &amp;&amp; linker.input.empty? then
  links = linker.additional_menu("")
  lines = INPUT.split("\n")
  row = ENV['TM_LINE_NUMBER'].to_i
  prevline = lines[row-2]
  linker.make_ref_list(links,prevline)
  exit
elsif linker.input.empty? &amp;&amp; ! ENV['TM_CURRENT_LINE'] =~ /^(\s+)?$/
  TextMate::CoolDialog.cool_tool_tip("I wouldn't do that in the middle of a paragraphâ€¦",true)
elsif linker.links.empty?
  if CLIPBOARD =~ /(?:\[([^\]]+)\]\: )?(https?:\/\/[^ \n"]+)/m
    input,url = linker.link_word(linker.input)
    is_ref = url =~ /^\[.*?\]$/ ? true : false
    if input.empty? &amp;&amp; !(ENV['TM_SCOPE'].scan(/markdown/).empty?) &amp;&amp; ENV['TM_CURRENT_LINE'] =~ /^(\s+)?$/
      domain = url.match(/https?:\/\/([^\/]+)/)
      parts = domain[1].split('.')
      name = case parts.length
        when 1: parts[0]
        when 2: parts[0]
        else parts[1]
      end
      linker.replace_if_needed("[#{name}]: #{url}\n")
    elsif !(ENV['TM_SCOPE'].scan(/markdown/).empty?) &amp;&amp; ENV['TM_CURRENT_LINE'] =~ /^(\s+|#{e_sn(input)})?$/
      skip = false
      linker.references.each { |ref|
        if ref.has_value?(url)
          TextMate::CoolDialog.cool_tool_tip("Repeat url: #{url}\nRepeat of reference: [#{ref['title']}]",false)
          skip = true
        end
      }
      if skip == true || is_ref
        TextMate::CoolDialog.cool_tool_tip("Repeat reference url: #{url}",false) if is_ref
        TextMate.exit_discard
      else
        linker.replace_if_needed("[#{input}]: #{url}")
      end
    else
      linker.references.each {|ref|
        if ref.has_value?(url)
          linker.replace_if_needed("[#{input}][#{ref['title']}]")
          exit
        end
      }
      if is_ref
        out = "[#{linker.input}]#{url}"
      else
        out = "[#{linker.input}](#{url})"
        # TODO: if the link isn't already a reference, insert a new ref link at the top or under existing refs, incrementing title as necessary
        # TODO: replace current word with ref link
      end
      linker.replace_if_needed(out)
    end
  else
    if linker.links.empty?
      if CLIPBOARD =~ /\[?([^\]]+)\]?(?:.*?)?/
        linkword = $1
        linker.references.each {|ref|
          if ref['title'] == $1
            linker.replace_if_needed("[#{linker.input}][#{ref['title']}]")
            exit
          end
        }
      end
	links = linker.additional_menu(linker.input)
	o = links[0][0] == "_ref" ? "[#{linker.input}][#{links[0][1]}]" : "[#{linker.input}](#{links[0][1]})"
	linker.replace_if_needed(o)
	exit
    end
  end
else
	links = linker.additional_menu('')
	lines = INPUT.split("\n")
	row = ENV['TM_LINE_NUMBER'].to_i
	prevline = lines[row-2]
	linker.make_ref_list(links,prevline)
	exit
end
</string>
	<key>fallbackInput</key>
	<string>document</string>
	<key>input</key>
	<string>document</string>
	<key>keyEquivalent</key>
	<string>~l</string>
	<key>name</key>
	<string>Super Linker</string>
	<key>output</key>
	<string>replaceSelectedText</string>
	<key>scope</key>
	<string>text.html.markdown.multimarkdown, text.html.markdown</string>
	<key>tabTrigger</key>
	<string>refs</string>
	<key>uuid</key>
	<string>6E088D62-39AB-47DD-AB76-8D767BEE125C</string>
</dict>
</plist>
